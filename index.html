<!DOCTYPE html>
<html>
<head>
    <title>éœ“è™¹ä¿„ç¾…æ–¯æ–¹å¡Š - æ‰‹æ©Ÿé›»è…¦å®Œç¾ç‰ˆ</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            height: 100vh; 
            background: #1a1a1a;
            display: flex; 
            flex-direction: column; 
            justify-content: center; 
            align-items: center; 
            font-family: Arial, sans-serif;
            color: white;
            touch-action: none;
            user-select: none;
        }
        canvas { 
            border: 3px solid #444; 
            box-shadow: 0 0 30px rgba(0,255,255,0.3);
            max-width: 90vw; max-height: 80vh;
            width: 300px; height: 600px;
        }
        .ui {
            position: absolute; 
            top: 20px; 
            left: 50%; 
            transform: translateX(-50%);
            text-align: center;
            font-size: clamp(18px, 4vw, 24px); 
            text-shadow: 0 0 10px cyan;
            z-index: 10;
        }
        .controls {
            position: fixed; bottom: 20px; left: 50%;
            transform: translateX(-50%);
            display: grid; grid-template-columns: repeat(3, 1fr);
            gap: 10px; max-width: 300px; width: 90vw;
        }
        .btn {
            aspect-ratio: 1; border: none;
            background: rgba(0,255,255,0.2);
            color: white; font-size: clamp(18px, 5vw, 24px);
            border-radius: 10px; backdrop-filter: blur(10px);
            touch-action: manipulation;
        }
        .btn:active { background: rgba(0,255,255,0.5); transform: scale(0.95); }
        .rotate { grid-column: 2; }
        .left { grid-column: 1; }
        .right { grid-column: 3; }
        .down { grid-row: 2; grid-column: 2; }
        #gameOver {
            display: none; position: fixed; top: 0; left: 0; 
            width: 100%; height: 100%; background: rgba(0,0,0,0.9);
            color: white; z-index: 1000; text-align: center; 
            padding-top: 30%; font-size: clamp(1.5em, 6vw, 3em);
        }
        #crisis-alert {
            display: none; position: fixed; top: 0; left: 0; 
            width: 100%; height: 100%; background: rgba(255,0,0,0.95);
            color: white; z-index: 99999; text-align: center; 
            padding-top: 25%; font-size: clamp(1.5em, 5vw, 3em);
        }
    </style>
</head>
<body>
    <div class="ui">
        åˆ†æ•¸: <span id="score">0</span> | æœ€é«˜åˆ†: <span id="highScore">0</span>
    </div>
    <canvas id="game" width="300" height="600"></canvas>
    
    <div class="controls">
        <button class="btn left" ontouchstart="move(-1)">â†</button>
        <button class="btn rotate" ontouchstart="rotate()">â†»</button>
        <button class="btn right" ontouchstart="move(1)">â†’</button>
        <button class="btn down" ontouchstart="drop()">â†“</button>
    </div>

    <div id="gameOver">
        <h1>ğŸ® éŠæˆ²çµæŸ ğŸ®</h1>
        <p>æœ€çµ‚åˆ†æ•¸: <span id="finalScore">0</span></p>
        <button onclick="restart()" style="padding:15px 30px;font-size:1.2em;margin:10px;">å†ç©ä¸€æ¬¡</button>
        <br><button onclick="closeGameOver()" style="padding:10px 20px;">æš«åœ</button>
    </div>

    <div id="crisis-alert">
        <h1>ğŸš¨ å±æ©Ÿè­¦å‘Š ğŸš¨</h1>
        <p>åµæ¸¬åˆ°ç·Šæ€¥äº‹ä»¶ï¼Œè«‹æ³¨æ„å®‰å…¨ï¼</p>
        <button onclick="location.reload()" style="padding:15px 30px;font-size:1.2em;">ç¹¼çºŒéŠæˆ²</button>
    </div>

    <script>
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const highScoreEl = document.getElementById('highScore');
        const gameOverEl = document.getElementById('gameOver');
        const finalScoreEl = document.getElementById('finalScore');

        // éœ“è™¹æ¼¸è®Šæ–¹å¡Šï¼ˆè·Ÿä½ åœ–ç‰‡å®Œå…¨ä¸€æ¨£ï¼‰
        const tetrominoes = {
            'I': { color: ['#00f0ff','#00b8ff','#0080ff'], shape: [[1,1,1,1]] },
            'O': { color: ['#fff700','#ffeb3b','#ffd600'], shape: [[1,1],[1,1]] },
            'T': { color: ['#b300ff','#9c27b0','#7b1fa2'], shape: [[0,1,0],[1,1,1]] },
            'S': { color: ['#00ff88','#00e676','#00c853'], shape: [[0,1,1],[1,1,0]] },
            'Z': { color: ['#ff4444','#f44336','#d32f2f'], shape: [[1,1,0],[0,1,1]] },
            'J': { color: ['#4488ff','#2196f3','#1976d2'], shape: [[1,0,0],[1,1,1]] },
            'L': { color: ['#ffaa00','#ff9800','#f57c00'], shape: [[0,0,1],[1,1,1]] }
        };

        let board = Array(20).fill().map(() => Array(10).fill(0));
        let current = { x: 3, y: 0, type: getRandomTetromino() };
        let score = 0, highScore = localStorage.getItem('tetrisHighScore') || 0;
        let dropTime = 0, DROP_INTERVAL = 500, gameRunning = true;
        let touchStartX, touchStartY;

        highScoreEl.textContent = highScore;

        function getRandomTetromino() {
            const types = Object.keys(tetrominoes);
            return { type: types[Math.floor(Math.random() * types.length)], rotation: 0 };
        }

        function drawBlock(x, y, colors) {
            ctx.save();
            const gradient = ctx.createLinearGradient(x*30, y*30, x*30+30, y*30+30);
            gradient.addColorStop(0, colors[0]); gradient.addColorStop(0.5, colors[1]); gradient.addColorStop(1, colors[2]);
            ctx.fillStyle = gradient; ctx.shadowColor = colors[0]; ctx.shadowBlur = 15;
            ctx.fillRect(x*30, y*30, 30, 30); ctx.shadowBlur = 0;
            ctx.strokeStyle = colors[0]; ctx.lineWidth = 2; ctx.strokeRect(x*30+1, y*30+1, 28, 28);
            ctx.restore();
        }

        function draw() {
            ctx.fillStyle = '#111'; ctx.fillRect(0, 0, 300, 600);
            for (let y = 0; y < 20; y++) for (let x = 0; x < 10; x++) 
                if (board[y][x]) drawBlock(x, y, tetrominoes[board[y][x]].color);
            const piece = tetrominoes[current.type.type];
            for (let py = 0; py < piece.shape.length; py++) for (let px = 0; px < piece.shape[py].length; px++)
                if (piece.shape[py][px]) drawBlock(current.x + px, current.y + py, piece.color);
        }

        function collide(dx=0, dy=0) {
            const piece = tetrominoes[current.type.type].shape;
            for (let y = 0; y < piece.length; y++) for (let x = 0; x < piece[y].length; x++)
                if (piece[y][x]) {
                    const newX = current.x + x + dx, newY = current.y + y + dy;
                    if (newX < 0 || newX >= 10 || newY >= 20 || (newY >= 0 && board[newY][newX])) return true;
                }
            return false;
        }

        function merge() {
            const piece = tetrominoes[current.type.type].shape;
            for (let y = 0; y < piece.length; y++) for (let x = 0; x < piece[y].length; x++)
                if (piece[y][x]) board[current.y + y][current.x + x] = current.type.type;
        }

        function clearLines() {
            for (let y = 19; y >= 0; y--) if (board[y].every(cell => cell !== 0)) {
                board.splice(y, 1); board.unshift(Array(10).fill(0)); score += 100; y++;
            }
            scoreEl.textContent = score;
            if (score > highScore) {
                highScore = score; highScoreEl.textContent = highScore;
                localStorage.setItem('tetrisHighScore', highScore);
            }
        }

        function rotate() {
            const piece = tetrominoes[current.type.type];
            const rotated = piece.shape[0].map((_, i) => piece.shape.map(row => row[i]).reverse());
            const prevShape = piece.shape; piece.shape = rotated;
            if (collide()) piece.shape = prevShape;
        }

        function gameOver() {
            gameRunning = false;
            finalScoreEl.textContent = score;
            gameOverEl.style.display = 'block';
        }

        function restart() {
            board = Array(20).fill().map(() => Array(10).fill(0));
            current = getRandomTetromino(); score = 0; dropTime = 0; gameRunning = true;
            scoreEl.textContent = score; gameOverEl.style.display = 'none';
        }

        function closeGameOver() {
            gameOverEl.style.display = 'none';
        }

        // é›»è…¦éµç›¤
        document.addEventListener('keydown', e => {
            if (!gameRunning) return;
            if (e.key === 'ArrowLeft' && !collide(-1, 0)) current.x--;
            if (e.key === 'ArrowRight' && !collide(1, 0)) current.x++;
            if (e.key === 'ArrowDown' && !collide(0, 1)) current.y++;
            if (e.key === 'ArrowUp') rotate();
        });

        // æ‰‹æ©Ÿæ§åˆ¶
        function move(dx) { if (gameRunning && !collide(dx, 0)) current.x += dx; }
        function drop() { if (gameRunning && !collide(0, 1)) current.y++; }

        canvas.addEventListener('touchstart', e => {
            e.preventDefault(); touchStartX = e.touches[0].clientX; touchStartY = e.touches[0].clientY;
        });
        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            if (!touchStartX || !gameRunning) return;
            const deltaX = e.touches[0].clientX - touchStartX;
            const deltaY = e.touches[0].clientY - touchStartY;
            if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 30) {
                move(deltaX > 0 ? 1 : -1); touchStartX = null;
            } else if (Math.abs(deltaY) > 30) {
                drop(); touchStartY = null;
            }
        });

        // å±æ©Ÿè­¦å‘Š
        function checkCrisis() {
            fetch('https://api.meteodata.tw/v1/earthquake').then(r=>r.json()).then(data=>{
                if (data && data.alert) document.getElementById('crisis-alert').style.display = 'block';
            }).catch(()=>{}); 
        }
        setInterval(checkCrisis, 30000); checkCrisis();

        function update(time = 0) {
            if (!gameRunning) { draw(); requestAnimationFrame(update); return; }
            
            dropTime += time - (dropTime || time);
            if (dropTime > DROP_INTERVAL) {
                if (!collide(0, 1)) {
                    current.y++;
                } else {
                    current.y--; merge(); clearLines();
                    current = getRandomTetromino();
                    if (collide()) gameOver();
                    dropTime = 0;
                }
            }
            draw(); requestAnimationFrame(update);
        }

        update();
    </script>
</body>
</html>
