<!DOCTYPE html>
<html>
<head>
    <title>慢速俄羅斯方塊 - 升級版</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            height: 100vh; 
            background: #1a1a1a;
            display: flex; 
            flex-direction: column; 
            justify-content: center; 
            align-items: center; 
            font-family: Arial, sans-serif;
            color: white;
        }
        canvas { 
            border: 3px solid #444; 
            background: #000;
            box-shadow: 0 0 20px #00ffff;
        }
        .info {
            display: flex; gap: 30px; margin-top: 20px; font-size: 20px;
        }
        .level-up {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 4em; font-weight: bold; color: #ffff00; text-shadow: 0 0 20px #ffff00;
            display: none; z-index: 1000; pointer-events: none;
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 0.7; transform: translate(-50%, -50%) scale(1.2); }
        }
    </style>
</head>
<body>
    <canvas id="game" width="300" height="600"></canvas>
    <div class="info">
        <div>分數: <span id="score">0</span></div>
        <div>等級: <span id="level">1</span> (破<span id="linesNeeded">5</span>行)</div>
    </div>
    <div id="levelUp" class="level-up">LEVEL UP!</div>

    <script>
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        const grid = 30;
        let board = Array(20).fill().map(() => Array(10).fill(0));
        let score = 0, level = 1, linesCleared = 0, linesNeeded = 5;
        
        const tetrominos = [
            [[1,1,1,1]], // I
            [[1,1],[1,1]], // O
            [[0,1,0],[1,1,1]], // T
            [[0,1,1],[1,1,0]], // S
            [[1,1,0],[0,1,1]], // Z
            [[1,0,0],[1,1,1]], // J
            [[0,0,1],[1,1,1]]  // L
        ];
        const colors = ['#00ffff', '#ffff00', '#aa00ff', '#00ff00', '#ff0000', '#0000ff', '#ff8800'];

        let current = {
            shape: tetrominos[Math.floor(Math.random() * 7)],
            color: Math.floor(Math.random() * 7),
            x: 3, y: 0
        };

        let dropTime = 0;
        const dropSpeed = [1000, 900, 800, 700, 600]; // 慢慢掉落，每級略加速

        // 繪製
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 棋盤
            for(let r=0; r<20; r++) {
                for(let c=0; c<10; c++) {
                    if(board[r][c]) {
                        ctx.fillStyle = colors[board[r][c]-1];
                        ctx.fillRect(c*grid, r*grid, grid-1, grid-1);
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(c*grid, r*grid, grid-1, grid-1);
                    }
                }
            }
            
            // 當前行塊
            current.shape.forEach((row, dy) => {
                row.forEach((value, dx) => {
                    if(value) {
                        ctx.fillStyle = colors[current.color];
                        ctx.fillRect((current.x+dx)*grid, (current.y+dy)*grid, grid-1, grid-1);
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 2;
                        ctx.strokeRect((current.x+dx)*grid, (current.y+dy)*grid, grid-1, grid-1);
                    }
                });
            });
        }

        // 碰撞偵測
        function collide() {
            for(let y=0; y<current.shape.length; y++) {
                for(let x=0; x<current.shape[y].length; x++) {
                    if(current.shape[y][x] && 
                       (current.y + y >= 20 || current.x + x < 0 || current.x + x >= 10 || 
                        (current.y + y >= 0 && board[current.y + y]?.[current.x + x]))) {
                        return true;
                    }
                }
            }
            return false;
        }

        // 合併方塊
        function merge() {
            current.shape.forEach((row, y) => {
                row.forEach((value, x) => {
                    if(value) board[current.y + y][current.x + x] = current.color + 1;
                });
            });
        }

        // 清除行
        function clearLines() {
            let lines = 0;
            for(let r=19; r>=0; r--) {
                if(board[r].every(cell => cell !== 0)) {
                    board.splice(r, 1);
                    board.unshift(Array(10).fill(0));
                    lines++;
                    r++; // 重新檢查這行
                }
            }
            if(lines > 0) {
                linesCleared += lines;
                score += lines * 100 * level;
                document.getElementById('score').textContent = score;
                
                if(linesCleared >= linesNeeded) {
                    levelUp();
                } else {
                    document.getElementById('linesNeeded').textContent = linesNeeded - linesCleared;
                }
            }
        }

        // 升級動畫
        function levelUp() {
            level++;
            linesCleared = 0;
            linesNeeded = 5; // 固定每5行升級
            
            const levelUpDiv = document.getElementById('levelUp');
            levelUpDiv.style.display = 'block';
            document.getElementById('level').textContent = level;
            document.getElementById('linesNeeded').textContent = linesNeeded;
            
            setTimeout(() => {
                levelUpDiv.style.display = 'none';
            }, 2000);
        }

        // 新方塊
        function nextTetromino() {
            current.shape = tetrominos[Math.floor(Math.random() * 7)];
            current.color = Math.floor(Math.random() * 7);
            current.x = 3;
            current.y = 0;
            if(collide()) {
                board = Array(20).fill().map(() => Array(10).fill(0));
                score = 0; level = 1; linesCleared = 0; linesNeeded = 5;
                document.getElementById('score').textContent = score;
                document.getElementById('level').textContent = level;
                document.getElementById('linesNeeded').textContent = linesNeeded;
            }
        }

        // 更新
        function update(time = 0) {
            dropTime += time - (dropTime || time);
            if(dropTime > dropSpeed[Math.min(level-1, 4)]) {
                dropTime = 0;
                if(!collide()) {
                    current.y++;
                } else {
                    merge();
                    clearLines();
                    nextTetromino();
                }
            }
            draw();
            requestAnimationFrame(update);
        }

        // 控制（只左右+加速，無旋轉）
        document.addEventListener('keydown', e => {
            if(e.key === 'ArrowLeft' && !collide({x: current.x-1})) current.x--;
            if(e.key === 'ArrowRight' && !collide({x: current.x+1})) current.x++;
            if(e.key === 'ArrowDown') current.y++;
        });

        // 觸控控制
        let touchStartX, touchStartY;
        canvas.addEventListener('touchstart', e => {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        });
        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            let touchEndX = e.touches[0].clientX;
            let touchEndY = e.touches[0].clientY;
            if(touchEndX < touchStartX - 30) current.x = Math.max(0, current.x-1);
            if(touchEndX > touchStartX + 30) current.x = Math.min(9-current.shape[0].length, current.x+1);
            if(touchEndY > touchStartY + 30) current.y++;
        });

        nextTetromino();
        update();
    </script>
</body>
</html>
